<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
body{margin:0;overflow:hidden;font-family:sans-serif;}
#ui {
  position:absolute;
  top:20px;
  left:20px;
  background:rgba(255,255,255,0.95);
  box-shadow:0 0 10px rgba(0,0,0,0.3);
  font-size:14px;
  display:flex;
  flex-direction:column;
  width:300px;
  resize:both;
  overflow:auto;
  border-radius:6px;
  border:1px solid #ccc;
}
#uiHeader {
  cursor:move;
  background:#333;
  color:#fff;
  padding:8px;
  border-top-left-radius:6px;
  border-top-right-radius:6px;
  font-weight:bold;
  display:flex;
  justify-content:space-between;
  align-items:center;
  user-select:none;
}
#uiControls {
  padding:10px;
  background:#f9f9f9;
  flex:1;
  display:flex;
  flex-direction:column;
}
#ui button {
  margin-top:5px;
  padding:5px;
  background:#2196f3;
  border:none;
  color:#fff;
  cursor:pointer;
  border-radius:3px;
  font-size:13px;
}
#ui button:hover {
  background:#1976d2;
}
#console {
  font-family:monospace;
  background:#eee;
  padding:5px;
  margin-top:5px;
  height:150px;
  overflow:auto;
  white-space:pre-wrap;
  border:1px solid #ccc;
  border-radius:4px;
}
#toggleUI {
  position:absolute;
  top:20px;
  left:20px;
  background:#2196f3;
  border:none;
  color:#fff;
  padding:5px;
  cursor:pointer;
  border-radius:3px;
  font-size:13px;
  z-index:11;
}
#toggleUI:hover {
  background:#1976d2;
}
</style>
</head>
<body>
<button id="toggleUI">Toggle UI</button>
<div id="ui">
  <div id="uiHeader">
    <span>Pyraminx Control</span>
    <span style="cursor:pointer;" id="closeBtn">âœ–</span>
  </div>
  <div id="uiControls">
    <div style="margin-bottom:5px;">Enter JS commands:</div>
    <textarea id="codeInput" rows="10" style="width:100%;"></textarea>
    <button id="runBtn">Run Code</button>
    <div id="console"></div>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/examples/js/controls/OrbitControls.js"></script>
<script>
var scene=new THREE.Scene();
var camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(0,1.5,3);
var renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

var controls=new THREE.OrbitControls(camera,renderer.domElement);
var raycaster=new THREE.Raycaster();
var mouse=new THREE.Vector2();

function log(msg) {
  var c=document.getElementById('console');
  c.textContent+=msg+"\n";
  c.scrollTop=c.scrollHeight;
}

function makeColorTexture(color) {
  var size=64;
  var canvas=document.createElement('canvas');
  canvas.width=size;canvas.height=size;
  var ctx=canvas.getContext('2d');
  ctx.fillStyle=color;
  ctx.fillRect(0,0,size,size);
  var texture=new THREE.Texture(canvas);
  texture.needsUpdate=true;
  return texture;
}

var stickerTextures={
  yellow:makeColorTexture('#FFFF00'),
  blue:makeColorTexture('#0000FF'),
  red:makeColorTexture('#FF0000'),
  green:makeColorTexture('#00FF00')
};

var cornerPositions=[
  new THREE.Vector3(0,0,1),
  new THREE.Vector3(Math.sqrt(8/9),0,-1/3),
  new THREE.Vector3(-Math.sqrt(2/9),Math.sqrt(2/3),-1/3),
  new THREE.Vector3(-Math.sqrt(2/9),-Math.sqrt(2/3),-1/3)
];

var facesIndices=[[0,1,2],[0,2,3],[0,3,1],[1,3,2]];

function edgePoint(a,b,t){return new THREE.Vector3().lerpVectors(a,b,t);}
function faceCenter(pts){return new THREE.Vector3().addVectors(pts[0],pts[1]).add(pts[2]).divideScalar(3);}

var group=new THREE.Group();
scene.add(group);

var pieces=[];

function createStickerTriangle(p1,p2,p3,map){
  var g=new THREE.BufferGeometry();
  var verts=new Float32Array([
    p1.x,p1.y,p1.z,
    p2.x,p2.y,p2.z,
    p3.x,p3.y,p3.z
  ]);
  g.setAttribute('position',new THREE.BufferAttribute(verts,3));
  g.computeVertexNormals();
  
  var uvs=new Float32Array([
    0.5,1.0,
    0,0,
    1,0
  ]);
  g.setAttribute('uv',new THREE.BufferAttribute(uvs,2));
  
  var m=new THREE.MeshPhongMaterial({map:map,shininess:30});
  var mesh=new THREE.Mesh(g,m);

  var lineGeo = new THREE.EdgesGeometry(g);
  var lineMat = new THREE.LineBasicMaterial({color: 0x000000});
  var line = new THREE.LineSegments(lineGeo, lineMat);
  mesh.add(line);

  return mesh;
}

function createFaceGeometry(faceIndex){
  var c=facesIndices[faceIndex].map(i=>cornerPositions[i]);
  var center=faceCenter(c);
  var layerCoords=[];
  var vPairs=[[0,1],[1,2],[2,0]];
  for(var i=0;i<3;i++){
    layerCoords.push(edgePoint(c[vPairs[i][0]],c[vPairs[i][1]],1/3));
    layerCoords.push(edgePoint(c[vPairs[i][0]],c[vPairs[i][1]],2/3));
  }
  var colorKeys=["yellow","blue","red","green"];
  var faceColor=stickerTextures[colorKeys[faceIndex]];
  var faceGroup=new THREE.Group();

  var topTris=[ [c[0],layerCoords[0],layerCoords[5]],
                [c[1],layerCoords[2],layerCoords[1]],
                [c[2],layerCoords[4],layerCoords[3]] ];
  for(var i=0;i<topTris.length;i++){
    var t=topTris[i];
    var tri=createStickerTriangle(t[0],t[1],t[2],faceColor);
    tri.userData={faceIndex:faceIndex,color:colorKeys[faceIndex]};
    faceGroup.add(tri);
    pieces.push(tri);
  }

  for(var i=0;i<layerCoords.length;i++){
    var t=[center,layerCoords[i],layerCoords[(i+1)%layerCoords.length]];
    var tri=createStickerTriangle(t[0],t[1],t[2],faceColor);
    tri.userData={faceIndex:faceIndex,color:colorKeys[faceIndex]};
    faceGroup.add(tri);
    pieces.push(tri);
  }
  return faceGroup;
}

for(var f=0;f<4;f++){
  var fg=createFaceGeometry(f);
  group.add(fg);
}

var light=new THREE.DirectionalLight(0xffffff,1);
light.position.set(2,2,2);
scene.add(light);
scene.add(new THREE.AmbientLight(0x555555));

var rotationAxes=[
  {corner:0,neighbors:[1,2,3],axis:null},
  {corner:1,neighbors:[0,3,2],axis:null},
  {corner:2,neighbors:[0,1,3],axis:null},
  {corner:3,neighbors:[0,2,1],axis:null}
];
for(var i=0;i<rotationAxes.length;i++){
  var va=cornerPositions[rotationAxes[i].corner];
  var axis=va.clone().normalize();
  rotationAxes[i].axis=axis;
}

function attach(child, scene, parent){
  scene.updateMatrixWorld(true);
  child.updateMatrixWorld(true);
  var matrix=child.matrixWorld.clone();
  scene.remove(child);
  parent.add(child);
  parent.updateMatrixWorld(true);
  child.matrix.copy(parent.matrixWorld.clone().invert());
  child.matrix.multiply(matrix);
  child.matrix.decompose(child.position,child.quaternion,child.scale);
}

function detach(child, parent, scene){
  parent.updateMatrixWorld(true);
  child.updateMatrixWorld(true);
  var matrix=child.matrixWorld.clone();
  parent.remove(child);
  scene.add(child);
  child.matrix.copy(matrix);
  child.matrix.decompose(child.position,child.quaternion,child.scale);
}

var twisting=false;
var twistStart=0;
var twistDuration=0.3;
var twistFrom=0;
var twistTo=0;
var twistAxis=new THREE.Vector3();
var twistPieces=[];
var twistingGroup=new THREE.Group();
scene.add(twistingGroup);

function getLayerPieces(axisIndex){
  var ax=rotationAxes[axisIndex];
  var axis=ax.axis.clone();
  var threshold=0.0001;
  var selected=[];
  var tempBox=new THREE.Box3();
  group.updateMatrixWorld(true);
  group.traverse(function(o){
    if(o.isMesh){
      tempBox.setFromObject(o);
      var center=tempBox.getCenter(new THREE.Vector3());
      var proj=center.clone().normalize();
      var dot=proj.dot(axis);
      if(dot>0.3-threshold)selected.push(o);
    }
  });
  return selected;
}

function queueRotateLayer(axisIndex,dir) {
  commandQueue.push({type:'rotate',axisIndex:axisIndex,dir:dir});
  processQueue();
}

function queueGetState() {
  commandQueue.push({type:'state'});
  processQueue();
}

function doRotateLayer(axisIndex,dir,cb){
  if(twisting) { 
    if(cb) cb();
    return; 
  }
  twistAxis=rotationAxes[axisIndex].axis.clone();
  twistPieces=getLayerPieces(axisIndex);
  for(var i=0;i<twistPieces.length;i++){
    attach(twistPieces[i], scene, twistingGroup);
  }
  twistFrom=0;
  twistTo=Math.PI*2/3*(dir>0?1:-1);
  twistStart=performance.now()/1000;
  twisting=true;
  onTwistComplete=cb;
}

function getPyraminxState() {
  var state=[];
  var tempBox=new THREE.Box3();
  group.updateMatrixWorld(true);
  pieces.forEach(p=>{
    tempBox.setFromObject(p);
    var center=tempBox.getCenter(new THREE.Vector3());
    var dir=center.clone().normalize();
    var bestFace=-1;
    var bestDot=-1;
    for(var i=0;i<4;i++){
      var dot=dir.dot(rotationAxes[i].axis);
      if(dot>bestDot) { bestDot=dot; bestFace=i; }
    }
    state.push({currentFace:bestFace,originalColor:p.userData.color});
  });
  return state;
}

var onTwistComplete=null;

function animate(){
  var t=performance.now()/1000;
  if(twisting){
    var dt=t-twistStart;
    var progress=dt/twistDuration;
    if(progress>=1){
      progress=1;
      twisting=false;
    }
    var eased=progress<0.5?(2*progress*progress):( -1+(4-2*progress)*progress );
    var angle=twistFrom+(twistTo-twistFrom)*eased;
    twistingGroup.setRotationFromAxisAngle(twistAxis,angle);
    if(!twisting){
      for(var i=0;i<twistPieces.length;i++){
        detach(twistPieces[i],twistingGroup,group);
      }
      twistingGroup.rotation.set(0,0,0);
      twistPieces=[];
      if(onTwistComplete) onTwistComplete();
      onTwistComplete=null;
    }
  }
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

var commandQueue=[];
var executing=false;

function processQueue(){
  if(executing) return;
  if(commandQueue.length===0)return;
  executing=true;
  var cmd=commandQueue.shift();
  if(cmd.type==='rotate'){
    doRotateLayer(cmd.axisIndex,cmd.dir,function(){
      executing=false;
      processQueue();
    });
  } else if(cmd.type==='state'){
    var st=getPyraminxState();
    log("Current State:\n"+JSON.stringify(st,null,2));
    executing=false;
    processQueue();
  } else {
    executing=false;
    processQueue();
  }
}

window.rotateLayerCommand=function(faceIndex,dir){
  queueRotateLayer(faceIndex,dir);
};

window.getCurrentState=function(){
  queueGetState();
};

function scramble(){
  for(var i=0;i<8;i++){
    queueRotateLayer(Math.floor(Math.random()*4),(Math.random()<0.5)?1:-1);
  }
}

// Draggable UI
(function(){
  var ui=document.getElementById('ui');
  var header=document.getElementById('uiHeader');
  var offsetX=0,offsetY=0,dragging=false;
  header.addEventListener('mousedown',function(e){
    dragging=true;
    offsetX=e.clientX-ui.offsetLeft;
    offsetY=e.clientY-ui.offsetTop;
    e.preventDefault();
  });
  document.addEventListener('mousemove',function(e){
    if(dragging){
      ui.style.left=(e.clientX-offsetX)+'px';
      ui.style.top=(e.clientY-offsetY)+'px';
    }
  });
  document.addEventListener('mouseup',function(e){
    dragging=false;
  });
})();

document.getElementById('runBtn').addEventListener('click',function(){
  var code=document.getElementById('codeInput').value;
  scramble();
  var waitForScramble=setInterval(function(){
    if(!executing){
      clearInterval(waitForScramble);
      try {
        eval(code);
      } catch(e){
        log("Error: "+e);
      }
    }
  },100);
});

function mousePick(event){
  mouse.x=(event.clientX/window.innerWidth)*2-1;
  mouse.y=-(event.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  var intersects=raycaster.intersectObjects(pieces,true);
  if(intersects.length>0){
    var p=intersects[0].point.clone().normalize();
    var bestAxis=-1;
    var bestDot=-1;
    for(var i=0;i<rotationAxes.length;i++){
      var dot=p.dot(rotationAxes[i].axis);
      if(dot>bestDot){bestDot=dot;bestAxis=i;}
    }
    queueRotateLayer(bestAxis,1);
  }
}

window.addEventListener('mousedown',mousePick);

var keyDown=false;
window.addEventListener('keydown',function(e){
  if(keyDown)return;
  keyDown=true;
  if(e.key==='s') queueRotateLayer(Math.floor(Math.random()*4),(Math.random()<0.5)?1:-1);
  if(e.key==='r') getCurrentState();
});
window.addEventListener('keyup',function(e){keyDown=false;});

window.addEventListener('resize',function(){
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

log("Type commands in the textarea and click Run Code.\nAvailable commands:\nrotateLayerCommand(faceIndex,direction);\ngetCurrentState();\nClick on the puzzle to rotate a selected layer.\nOn run, the puzzle will scramble first before executing your code.");

// Toggle UI
var ui=document.getElementById('ui');
var toggleBtn=document.getElementById('toggleUI');
toggleBtn.addEventListener('click',function(){
  if(ui.style.display==='none'){
    ui.style.display='flex';
    toggleBtn.textContent='Toggle UI';
  } else {
    ui.style.display='none';
    toggleBtn.textContent='Show UI';
  }
});

// Close Button
document.getElementById('closeBtn').addEventListener('click',function(){
  ui.style.display='none';
  toggleBtn.textContent='Show UI';
});
</script>
</body>
</html>
